---
// This is the Astro wrapper - the actual game logic runs client-side
---

<div id="game-board-container" class="w-full max-w-lg mx-auto">
  <div
    id="puzzle-grid"
    class="grid gap-1 bg-slate-800 p-2 rounded-lg aspect-square"
    style="grid-template-columns: repeat(4, 1fr);"
  >
    <!-- Tiles will be generated by JavaScript -->
  </div>

  <div id="win-message" class="hidden mt-4 p-4 bg-green-600 text-white rounded-lg text-center">
    <h2 class="text-2xl font-bold mb-2">Congratulations!</h2>
    <p id="win-stats"></p>
  </div>
</div>

<script>
  import {
    $difficulty,
    $imageUrl,
    $isPlaying,
    $isWon,
    $tiles,
    $emptyPosition,
    $moves,
    $elapsedTime,
    startGame,
    moveTile,
    getAdjacentPositions
  } from '../stores/gameStore';

  const grid = document.getElementById('puzzle-grid') as HTMLDivElement;
  const winMessage = document.getElementById('win-message') as HTMLDivElement;
  const winStats = document.getElementById('win-stats') as HTMLParagraphElement;

  // Scramble algorithm using "Reverse Walk" - guaranteed solvable
  function scramblePuzzle(gridSize: number, moves: number = 100): { tiles: number[], emptyPos: number } {
    const totalTiles = gridSize * gridSize;

    // Start with solved state: tile i at position i
    // tiles[i] = position of tile i
    const tiles: number[] = [];
    for (let i = 0; i < totalTiles; i++) {
      tiles[i] = i;
    }

    // Empty tile starts at the last position (bottom-right)
    let emptyPos = totalTiles - 1;
    let lastPos = -1; // Track last position to avoid immediate reversal

    // Perform random walk from solved state
    for (let i = 0; i < moves; i++) {
      const adjacent = getAdjacentPositions(emptyPos, gridSize);

      // Filter out the last position to prevent A -> B -> A
      const validMoves = adjacent.filter(pos => pos !== lastPos);

      // Pick a random adjacent position
      const randomIndex = Math.floor(Math.random() * validMoves.length);
      const newEmptyPos = validMoves[randomIndex];

      // Find which tile is at that position and swap
      const tileAtNewPos = tiles.findIndex(pos => pos === newEmptyPos);
      if (tileAtNewPos !== -1) {
        tiles[tileAtNewPos] = emptyPos;
      }

      lastPos = emptyPos;
      emptyPos = newEmptyPos;
    }

    return { tiles, emptyPos };
  }

  // Render the puzzle grid
  function renderGrid() {
    const difficulty = $difficulty.get();
    const tiles = $tiles.get();
    const emptyPos = $emptyPosition.get();
    const imageUrl = $imageUrl.get();
    const isPlaying = $isPlaying.get();

    // Update grid columns
    grid.style.gridTemplateColumns = `repeat(${difficulty}, 1fr)`;
    grid.innerHTML = '';

    const totalTiles = difficulty * difficulty;
    const tileSize = 100 / difficulty; // Percentage for background-position

    // Create a map: position -> tile number
    const positionMap: Map<number, number> = new Map();
    tiles.forEach((pos, tileNum) => {
      positionMap.set(pos, tileNum);
    });

    // Render tiles by position
    for (let position = 0; position < totalTiles; position++) {
      const tile = document.createElement('div');
      tile.classList.add(
        'aspect-square',
        'rounded',
        'cursor-pointer',
        'transition-all',
        'duration-150',
        'hover:brightness-110'
      );

      if (position === emptyPos) {
        // Empty tile
        tile.classList.add('bg-slate-700');
        tile.dataset.empty = 'true';
      } else {
        const tileNum = positionMap.get(position);

        if (tileNum !== undefined && imageUrl) {
          // Calculate the original row/col for this tile number
          const originalRow = Math.floor(tileNum / difficulty);
          const originalCol = tileNum % difficulty;

          // CSS background-position trick: show the correct portion of the image
          const bgPosX = (originalCol / (difficulty - 1)) * 100;
          const bgPosY = (originalRow / (difficulty - 1)) * 100;

          tile.style.backgroundImage = `url(${imageUrl})`;
          tile.style.backgroundSize = `${difficulty * 100}%`;
          tile.style.backgroundPosition = `${bgPosX}% ${bgPosY}%`;
        } else {
          // Fallback: numbered tiles
          tile.classList.add('bg-blue-600', 'flex', 'items-center', 'justify-center', 'text-white', 'font-bold', 'text-xl');
          if (tileNum !== undefined) {
            tile.textContent = String(tileNum + 1);
          }
        }

        tile.dataset.position = String(position);
      }

      // Click handler
      if (isPlaying && position !== emptyPos) {
        tile.addEventListener('click', () => {
          moveTile(position);
        });
      }

      grid.appendChild(tile);
    }
  }

  // Initialize or start new game
  function initGame() {
    const difficulty = $difficulty.get();
    const scrambleMoves = difficulty * difficulty * 20; // More moves for harder difficulties
    const { tiles, emptyPos } = scramblePuzzle(difficulty, scrambleMoves);
    startGame(tiles, emptyPos);
  }

  // Subscribe to state changes
  $tiles.subscribe(renderGrid);
  $difficulty.subscribe(renderGrid);
  $isPlaying.subscribe(renderGrid);

  $isWon.subscribe((won) => {
    if (won) {
      winMessage.classList.remove('hidden');
      const moves = $moves.get();
      const time = $elapsedTime.get();
      const minutes = Math.floor(time / 60);
      const seconds = time % 60;
      winStats.textContent = `Solved in ${moves} moves and ${minutes}:${seconds.toString().padStart(2, '0')}!`;
    } else {
      winMessage.classList.add('hidden');
    }
  });

  // Expose initGame globally for the start button
  (window as any).initGame = initGame;

  // Initial render (empty state)
  renderGrid();
</script>
